# This file is automatically generated. See `src/frontend/planner_test/README.md` for more information.
- sql: |
    create table t (v1 int, v2 int, v3 int);
    select v1, min(v2), count(distinct v3) as agg from t group by v1;
  stream_plan: |-
    StreamMaterialize { columns: [v1, min, agg], stream_key: [v1], pk_columns: [v1], pk_conflict: NoCheck }
    └─StreamProject { exprs: [t.v1, min(t.v2), count(distinct t.v3)] }
      └─StreamHashAgg { group_key: [t.v1], aggs: [min(t.v2), count(distinct t.v3), count] }
        └─StreamExchange { dist: HashShard(t.v1) }
          └─StreamTableScan { table: t, columns: [t.v1, t.v2, t.v3, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_error: |-
    Not supported: The query cannot be executed in Emit-On-Window-Close mode.
    HINT: Please make sure there is one and only one watermark column in GROUP BY
- sql: |
    create source t (v1 int, v2 int, v3 int, watermark for v1 as v1 - 10) with (connector = 'kinesis') FORMAT PLAIN ENCODE JSON;
    select v1, min(v2), count(distinct v3) as agg from t group by v1;
  stream_plan: |-
    StreamMaterialize { columns: [v1, min, agg], stream_key: [v1], pk_columns: [v1], pk_conflict: NoCheck, watermark_columns: [v1] }
    └─StreamProject { exprs: [v1, min(v2), count(distinct v3)], output_watermarks: [v1] }
      └─StreamHashAgg [append_only] { group_key: [v1], aggs: [min(v2), count(distinct v3), count], output_watermarks: [v1] }
        └─StreamExchange { dist: HashShard(v1) }
          └─StreamRowIdGen { row_id_index: 3 }
            └─StreamWatermarkFilter { watermark_descs: [Desc { column: v1, expr: (v1 - 10:Int32) }], output_watermarks: [v1] }
              └─StreamSource { source: t, columns: [v1, v2, v3, _row_id] }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [v1, min, agg], stream_key: [v1], pk_columns: [v1], pk_conflict: NoCheck, watermark_columns: [v1] }
    └─StreamProject { exprs: [v1, min(v2), count(distinct v3)], output_watermarks: [v1] }
      └─StreamHashAgg [append_only, eowc] { group_key: [v1], aggs: [min(v2), count(distinct v3), count], output_watermarks: [v1] }
        └─StreamExchange { dist: HashShard(v1) }
          └─StreamRowIdGen { row_id_index: 3 }
            └─StreamWatermarkFilter { watermark_descs: [Desc { column: v1, expr: (v1 - 10:Int32) }], output_watermarks: [v1] }
              └─StreamSource { source: t, columns: [v1, v2, v3, _row_id] }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [v1, min, agg], stream_key: [v1], pk_columns: [v1], pk_conflict: NoCheck, watermark_columns: [v1] }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [v1, min(v2), count(distinct v3)], output_watermarks: [v1] }
        └── StreamHashAgg [append_only, eowc] { group_key: [v1], aggs: [min(v2), count(distinct v3), count], output_watermarks: [v1] }
            ├── intermediate state table: 0
            ├── state tables: []
            ├── distinct tables: [ (distinct key: v3, table id: 1) ]
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamRowIdGen { row_id_index: 3 }
    └── StreamWatermarkFilter { watermark_descs: [Desc { column: v1, expr: (v1 - 10:Int32) }], output_watermarks: [v1] }
        ├── state tables: [ 2 ]
        └── StreamSource { source: t, columns: [v1, v2, v3, _row_id] } { source state table: 3 }

    Table 0
    ├── columns: [ v1, min(v2), count(distinct v3), count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ v1, v3, count_for_agg_call_1 ]
    ├── primary key: [ $0 ASC, $1 ASC ]
    ├── value indices: [ 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 2

    Table 2
    ├── columns: [ vnode, offset ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3
    ├── columns: [ partition_id, offset_info ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 1

    Table 4294967294
    ├── columns: [ v1, min, agg ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 0 ]
    └── read pk prefix len hint: 1

- sql: |
    CREATE TABLE t (a TIMESTAMP, b INT, WATERMARK FOR a AS a - INTERVAL '5 minutes') APPEND ONLY;
    SELECT
        window_start, max(b)
    FROM tumble(t, a, INTERVAL '1 hour')
    GROUP BY window_start;
  stream_plan: |-
    StreamMaterialize { columns: [window_start, max], stream_key: [window_start], pk_columns: [window_start], pk_conflict: NoCheck, watermark_columns: [window_start] }
    └─StreamProject { exprs: [$expr1, max(t.b)], output_watermarks: [$expr1] }
      └─StreamHashAgg [append_only] { group_key: [$expr1], aggs: [max(t.b), count], output_watermarks: [$expr1] }
        └─StreamExchange { dist: HashShard($expr1) }
          └─StreamProject { exprs: [TumbleStart(t.a, '01:00:00':Interval) as $expr1, t.b, t._row_id], output_watermarks: [$expr1] }
            └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_plan: |-
    StreamMaterialize { columns: [window_start, max], stream_key: [window_start], pk_columns: [window_start], pk_conflict: NoCheck, watermark_columns: [window_start] }
    └─StreamProject { exprs: [$expr1, max(t.b)], output_watermarks: [$expr1] }
      └─StreamHashAgg [append_only, eowc] { group_key: [$expr1], aggs: [max(t.b), count], output_watermarks: [$expr1] }
        └─StreamExchange { dist: HashShard($expr1) }
          └─StreamProject { exprs: [TumbleStart(t.a, '01:00:00':Interval) as $expr1, t.b, t._row_id], output_watermarks: [$expr1] }
            └─StreamTableScan { table: t, columns: [t.a, t.b, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [window_start, max], stream_key: [window_start], pk_columns: [window_start], pk_conflict: NoCheck, watermark_columns: [window_start] }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [$expr1, max(t.b)], output_watermarks: [$expr1] }
        └── StreamHashAgg [append_only, eowc] { group_key: [$expr1], aggs: [max(t.b), count], output_watermarks: [$expr1] }
            ├── intermediate state table: 0
            ├── state tables: []
            ├── distinct tables: []
            └── StreamExchange Hash([0]) from 1

    Fragment 1
    StreamProject { exprs: [TumbleStart(t.a, '01:00:00':Interval) as $expr1, t.b, t._row_id], output_watermarks: [$expr1] }
    └── Chain { table: t, columns: [t.a, t.b, t._row_id], pk: [t._row_id], dist: UpstreamHashShard(t._row_id) } { state table: 1 }
        ├── Upstream
        └── BatchPlanNode

    Table 0 { columns: [ $expr1, max(t_b), count ], primary key: [ $0 ASC ], value indices: [ 1, 2 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

    Table 1
    ├── columns: [ vnode, _row_id, t_backfill_finished, t_row_count ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1, 2, 3 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 4294967294 { columns: [ window_start, max ], primary key: [ $0 ASC ], value indices: [ 0, 1 ], distribution key: [ 0 ], read pk prefix len hint: 1 }

- sql: |
    create source t (a int, b int, tm timestamp, watermark for tm as tm - interval '5 minutes') with (connector = 'kinesis') FORMAT PLAIN ENCODE JSON;
    select lag(a, 2) over (partition by b order by tm) from t;
  eowc_stream_plan: |-
    StreamMaterialize { columns: [lag, _row_id(hidden), b(hidden)], stream_key: [_row_id, b], pk_columns: [_row_id, b], pk_conflict: NoCheck }
    └─StreamProject { exprs: [first_value, _row_id, b] }
      └─StreamEowcOverWindow { window_functions: [first_value(a) OVER(PARTITION BY b ORDER BY tm ASC ROWS BETWEEN 2 PRECEDING AND 2 PRECEDING)] }
        └─StreamEowcSort { sort_column: tm }
          └─StreamExchange { dist: HashShard(b) }
            └─StreamProject { exprs: [a, b, tm, _row_id], output_watermarks: [tm] }
              └─StreamRowIdGen { row_id_index: 3 }
                └─StreamWatermarkFilter { watermark_descs: [Desc { column: tm, expr: (tm - '00:05:00':Interval) }], output_watermarks: [tm] }
                  └─StreamSource { source: t, columns: [a, b, tm, _row_id] }
  eowc_stream_dist_plan: |+
    Fragment 0
    StreamMaterialize { columns: [lag, _row_id(hidden), b(hidden)], stream_key: [_row_id, b], pk_columns: [_row_id, b], pk_conflict: NoCheck }
    ├── materialized table: 4294967294
    └── StreamProject { exprs: [first_value, _row_id, b] }
        └── StreamEowcOverWindow { window_functions: [first_value(a) OVER(PARTITION BY b ORDER BY tm ASC ROWS BETWEEN 2 PRECEDING AND 2 PRECEDING)] }
            ├── state table: 0
            └── StreamEowcSort { sort_column: tm } { state table: 1 }
                └── StreamExchange Hash([1]) from 1

    Fragment 1
    StreamProject { exprs: [a, b, tm, _row_id], output_watermarks: [tm] }
    └── StreamRowIdGen { row_id_index: 3 }
        └── StreamWatermarkFilter { watermark_descs: [Desc { column: tm, expr: (tm - '00:05:00':Interval) }], output_watermarks: [tm] }
            ├── state tables: [ 2 ]
            └── StreamSource { source: t, columns: [a, b, tm, _row_id] } { source state table: 3 }

    Table 0
    ├── columns: [ a, b, tm, _row_id ]
    ├── primary key: [ $1 ASC, $2 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 1

    Table 1
    ├── columns: [ a, b, tm, _row_id ]
    ├── primary key: [ $2 ASC, $1 ASC, $3 ASC ]
    ├── value indices: [ 0, 1, 2, 3 ]
    ├── distribution key: [ 1 ]
    └── read pk prefix len hint: 0

    Table 2
    ├── columns: [ vnode, offset ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 1 ]
    ├── distribution key: [ 0 ]
    ├── read pk prefix len hint: 1
    └── vnode column idx: 0

    Table 3
    ├── columns: [ partition_id, offset_info ]
    ├── primary key: [ $0 ASC ]
    ├── value indices: [ 0, 1 ]
    ├── distribution key: []
    └── read pk prefix len hint: 1

    Table 4294967294
    ├── columns: [ lag, _row_id, b ]
    ├── primary key: [ $1 ASC, $2 ASC ]
    ├── value indices: [ 0, 1, 2 ]
    ├── distribution key: [ 2 ]
    └── read pk prefix len hint: 2

- sql: |
    create table t (tm timestamp, foo int, bar int, watermark for tm as tm - interval '5 minutes') append only;
    explain create sink s1 as
    select
      tm, foo, bar,
      lag(foo, 2) over (partition by bar order by tm),
      max(foo) over (partition by bar order by tm rows between 1 preceding and 1 following),
      sum(foo) over (partition by bar order by tm rows 2 preceding exclude current row)
    from t
    emit on window close
    WITH (connector = 'blackhole');
  explain_output: |
    StreamSink { type: upsert, columns: [tm, foo, bar, t._row_id(hidden), lag, max, sum], pk: [t._row_id, t.bar] }
    └─StreamEowcOverWindow { window_functions: [first_value(t.foo) OVER(PARTITION BY t.bar ORDER BY t.tm ASC ROWS BETWEEN 2 PRECEDING AND 2 PRECEDING), max(t.foo) OVER(PARTITION BY t.bar ORDER BY t.tm ASC ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING), sum(t.foo) OVER(PARTITION BY t.bar ORDER BY t.tm ASC ROWS BETWEEN 2 PRECEDING AND CURRENT ROW EXCLUDE CURRENT ROW)] }
      └─StreamEowcSort { sort_column: t.tm }
        └─StreamExchange { dist: HashShard(t.bar) }
          └─StreamTableScan { table: t, columns: [tm, foo, bar, _row_id] }
